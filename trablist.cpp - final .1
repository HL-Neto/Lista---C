#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#define MAX 60

typedef struct listaEncadeada {
    char disciplina;
    int nota;
    struct listaEncadeada *prox;
} ListaEncadeada;

typedef struct {
    int rgm;
    ListaEncadeada *disciplinas; // Lista de disciplinas do aluno
} Aluno;

typedef struct {
    Aluno vetor[MAX];
    int ultimaPosicao;
} Lista;

Lista criar() {
    Lista lista;
    lista.ultimaPosicao = -1;
    return lista;
}

int listaVazia(Lista *lista) {
    return (lista->ultimaPosicao == -1);
}

int listaCheia(Lista *lista) {
    return (lista->ultimaPosicao == MAX - 1);
}

int tamanhoAtualLista(Lista *lista) {
    return lista->ultimaPosicao + 1;
}

int buscaSequencial(Lista *lista, int rgm_busca) {
    for (int i = 0; i <= lista->ultimaPosicao; i++) {
        if (lista->vetor[i].rgm == rgm_busca) {
            return i;
        }
    }
    return -1;
}

void liberarDisciplinas(ListaEncadeada *lista) {
    ListaEncadeada *atual = lista;
    while (atual != NULL) {
        ListaEncadeada *prox = atual->prox;
        free(atual);
        atual = prox;
    }
}

int removerAluno(Lista *lista, int rgm) {
    int indice = buscaSequencial(lista, rgm);
    if (indice == -1) {
        return -1;
    }

    // Libera a memória das disciplinas do aluno
    liberarDisciplinas(lista->vetor[indice].disciplinas);

    // Remove o aluno e ajusta a lista
    for (int i = indice; i < lista->ultimaPosicao; i++) {
        lista->vetor[i] = lista->vetor[i + 1];
    }
    lista->ultimaPosicao--;

    printf("RGM excluido\n");
    return 0;
}

int main() {
    int resposta;
    Lista novaLista = criar();

    do {
        printf("Menu\n 1.INCLUIR\n 2.BUSCAR\n 3.MOSTRAR\n 4.REMOVER \n");
        printf("escolha uma opcao:\n");
        scanf("%d", &resposta);

        switch (resposta) {
            case 1:
                if (listaCheia(&novaLista)) {
                    printf("A lista está cheia e não dá para adicionar novos contatos!\n");
                } else {
                    Aluno novo_aluno;
                    char disciplina;
                    char continuar;

                    printf("Qual o RGM que você deseja adicionar?:\n");
                    scanf("%d", &novo_aluno.rgm);
                    novo_aluno.disciplinas = NULL;

                    do {
                        printf("Digite a disciplina do aluno matriculado:\n");
                        scanf(" %c", &disciplina);

                        ListaEncadeada *nova_disciplina = (ListaEncadeada*) malloc(sizeof(ListaEncadeada));
                        nova_disciplina->disciplina = disciplina;
                        nova_disciplina->nota = 0;
                        nova_disciplina->prox = NULL;

                        if (novo_aluno.disciplinas == NULL) {
                            novo_aluno.disciplinas = nova_disciplina;
                        } else {
                            ListaEncadeada *ultimo = novo_aluno.disciplinas;
                            while (ultimo->prox != NULL) {
                                ultimo = ultimo->prox;
                            }
                            ultimo->prox = nova_disciplina;
                        }

                        printf("Mais disciplinas? (s/n):\n");
                        scanf(" %c", &continuar);
                    } while (continuar == 's' || continuar == 'S');

                    novaLista.vetor[++novaLista.ultimaPosicao] = novo_aluno;
                    printf("Aluno atualizado!!\n");
                }
                break;

            case 2:
                if (listaVazia(&novaLista)) {
                    printf("A lista está vazia.\n");
                } else {
                    int rgm_busca;
                    printf("Digite o RGM:\n");
                    scanf("%d", &rgm_busca);
                    int busca = buscaSequencial(&novaLista, rgm_busca);
                    if (busca == -1) {
                        printf("Não existe;\n");
                    } else {
                        printf("Matrícula %d - RGM %d\n", busca + 1, rgm_busca);
                    }
                }
                break;

            case 3:
                if (listaVazia(&novaLista)) {
                    printf("A lista está vazia.\n");
                } else {
                    for (int i = 0; i <= novaLista.ultimaPosicao; i++) {
                        printf("Matrícula %d - RGM %d\n", i + 1, novaLista.vetor[i].rgm);
                    }
                }
                break;

            case 4:
                printf("Qual o RGM?:\n");
                int rgm;
                scanf("%d", &rgm);
                removerAluno(&novaLista, rgm);
                break;

            case 5:
                printf("Saindo...\n");
                break;

            default:
                printf("Opção inválida!\n");
        }
    } while (resposta != 5);

    // Liberar memória ao finalizar
    for (int i = 0; i <= novaLista.ultimaPosicao; i++) {
        liberarDisciplinas(novaLista.vetor[i].disciplinas);
    }

    return 0;
}
